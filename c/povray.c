#define PATCHLEVEL 0
/*
**    ScEd: A Constraint Based Scene Editor.
**    Copyright (C) 1994-1995  Stephen Chenney (stephen@cs.su.oz.au)
**
**    This program is free software; you can redistribute it and/or modify
**    it under the terms of the GNU General Public License as published by
**    the Free Software Foundation; either version 2 of the License, or
**    (at your option) any later version.
**
**    This program is distributed in the hope that it will be useful,
**    but WITHOUT ANY WARRANTY; without even the implied warranty of
**    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
**    GNU General Public License for more details.
**
**    You should have received a copy of the GNU General Public License
**    along with this program; if not, write to the Free Software
**    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
*/

/*
**	sced: A Constraint Based Object Scene Editor
**
**	povray.c : export functions for povray.
**
**	External function (there's just one).
**
**	void
**	Export_POVray(FILE *outfile)
**	Exports all the relevant info into outfile.
*/

#include <math.h>
#include <ctype.h>
#include <sced.h>
#include <base_objects.h>
#include <csg.h>
#include <hash.h>
#if HAVE_STRING_H
#include <string.h>
#elif HAVE_STRINGS_H
#include <strings.h>
#endif
#include <time.h>
#include <X11/Shell.h>
#include <X11/Xaw/AsciiText.h>
#include <X11/Xaw/Command.h>
#include <X11/Xaw/Form.h>
#include <X11/Xaw/Label.h>

extern double	Distance_Point_To_Plane(Vector, Vector, Vector);

static int	Export_Includes(FILE*);
static int	Export_Camera(FILE *, Camera);
static int	Export_Light(FILE *, ObjectInstancePtr);
static int	Export_All_Transforms(FILE*, InstanceList);
static int	Export_Basetypes(FILE*, BaseObjectPtr);
static int	Export_CSG_Tree(FILE*, CSGNodePtr);
static int	Export_Wireframe(FILE*, WireframePtr);
static int	Export_Instances(FILE *, InstanceList);
static void Export_Object_Type(FILE*, BaseObjectPtr);
static void Export_Attributes(FILE*, AttributePtr);
static int	Export_Declarations(FILE*, XColor);

static void	POV_Create_Include_Dialog();
static void	POV_Cancel_Callback(Widget, XtPointer, XtPointer);

#define POVVPrint(v) fprintf(outfile, "< %1.15g, %1.15g, %1.15g >\n", (v).x, (v).y, (v).z);

/* Stuff to allow exporting of transformation. */
static char	transform_name[16];
static HashTable	base_hash;
static HashTable	transform_hash;
static long			transform_number;

/* Include file handling. */
static char		*includes = NULL;
static Widget	pov_include_shell = NULL;
static Widget	pov_include_text;


/*	int
**	Export_POVray(FILE *outfile, ScenePtr scene)
**	Exports all the relevant info into outfile.
*/
int
Export_POVray(FILE *outfile, ScenePtr scene)
{
	time_t	current_time;

	time(&current_time);

	debug(FUNC_NAME,fprintf(stderr,"Export_POVray()\n"));

	base_hash = Hash_New_Table();
	transform_hash = Hash_New_Table();

	transform_number = 0;

	if ( fprintf(outfile, "// File generated by sced\n") < 0 ||
		 fprintf(outfile, "// %s\n", ctime(&current_time)) < 0 ||
		 Export_Includes(outfile) < 0 ||
		 Export_Declarations(outfile, scene->ambient) < 0 ||
		 Export_Camera(outfile, scene->camera) < 0 ||
		 Export_Light(outfile, scene->light) < 0 ||
		 Export_All_Transforms(outfile, scene->instances) < 0 ||
		 Export_Instances(outfile, scene->instances) < 0 )
 	{
 		Popup_Error("Write Failed!", main_window.shell, "Error");
 		return 0;
 	}

	return 1;
}



static int
Export_Camera(FILE *outfile, Camera cam)
{
	if ( cam.default_cam ) return 1;

	/* For povray, the camera is a big structure definition. */
	fprintf(outfile, "// Camera definition\n");
	fprintf(outfile, "camera {\n");
	fprintf(outfile, "\tlocation ");	POVVPrint(cam.location);
	fprintf(outfile, "\tsky ");			POVVPrint(cam.look_up);
	fprintf(outfile, "\tdirection <0, 0, %g>\n", cam.eye_dist);
	fprintf(outfile, "\tright <-%g, 0, 0>\n", cam.window_right);
	fprintf(outfile, "\tup <0, %g, 0>\n", cam.window_up);
	fprintf(outfile, "\tlook_at ");		POVVPrint(cam.look_at);

	return fprintf(outfile, "}\n\n");
}


static int
Export_Light(FILE *outfile, ObjectInstancePtr light)
{
	double	radius;
	double	cos_rad;
	Vector	direction;
	Vector	vect1, vect2;

	if ( ! light ) return 1;

	fprintf(outfile, "light_source {\n");
	fprintf(outfile, "\t");
	POVVPrint(light->o_transform.displacement);
	fprintf(outfile, "\tcolor red %g green %g blue %g\n",
			((LightInfoPtr)light->o_attribs)->red,
			((LightInfoPtr)light->o_attribs)->green,
			((LightInfoPtr)light->o_attribs)->blue);

	if ( light->o_parent->b_class == spotlight_obj )
	{
		/* Calculate the radius. */
		VSub(light->o_world_verts[0], light->o_world_verts[9], vect1);
		VSub(light->o_world_verts[8], light->o_world_verts[9], vect2);
		VUnit(vect1, radius, vect1);
		VUnit(vect2, radius, vect2);
		cos_rad = VDot(vect1, vect2);
		radius = acos(cos_rad) * 180 / M_PI;

		if ( ((LightInfoPtr)light->o_attribs)->flag )
		{
			/* Invert it. */
			/* vect2 still points toward direction. */
			VScalarMul(vect2, -1.0, vect2);
			VAdd(vect2, light->o_world_verts[9], direction);

			radius += 90.0;
		}
		else
			direction = light->o_world_verts[8];

		fprintf(outfile, "\tspotlight\n");
		fprintf(outfile, "\tpoint_at ");
		POVVPrint(direction);
		fprintf(outfile, "\tradius %g\n", radius);
		fprintf(outfile, "\tfalloff %g\n", radius *
				((LightInfoPtr)light->o_attribs)->val1);
		fprintf(outfile, "\ttightness %g\n",
				((LightInfoPtr)light->o_attribs)->val2);
	}

	if ( light->o_parent->b_class == arealight_obj )
	{
		/* Calculate the edges. */
		VSub(light->o_world_verts[0], light->o_world_verts[1], vect1);
		VSub(light->o_world_verts[3], light->o_world_verts[0], vect2);

		fprintf(outfile, "\tarea_light\n");
		fprintf(outfile, "\t");
		POVVPrint(vect1);
		fprintf(outfile, "\t,");
		POVVPrint(vect2);
		fprintf(outfile, "\t, %d, %d\n\tadaptive 3\n",
				(int)(((LightInfoPtr)light->o_attribs)->val1),
				(int)(((LightInfoPtr)light->o_attribs)->val2));
		if ( ((LightInfoPtr)light->o_attribs)->flag )
			fprintf(outfile, "\tjitter\n");
	}

	fprintf(outfile, "}\n");

	return fprintf(outfile, "\n");
}

static void
Export_Transform(FILE *outfile, ObjectInstancePtr inst)
{
	Matrix	transp;

	debug(FUNC_NAME,fprintf(stderr,"Export_Transform()\n"));

	Hash_Insert(transform_hash, (long)inst, (void*)transform_number);
	sprintf(transform_name, "transform_%ld", transform_number++);

	MTrans(inst->o_transform.matrix, transp);
	fprintf(outfile, "#declare %s = transform {\n", transform_name);
	fprintf(outfile, "\tmatrix\n");
	fprintf(outfile, "\t");	POVVPrint(transp.x);
	fprintf(outfile, "\t"); POVVPrint(transp.y);
	fprintf(outfile, "\t");	POVVPrint(transp.z);
	fprintf(outfile, "\ttranslate ");
	POVVPrint(inst->o_transform.displacement);
	fprintf(outfile, "\t}\n");

}

static int
Export_All_Transforms(FILE *outfile, InstanceList insts)
{       
    InstanceList	inst_elmt;

	debug(FUNC_NAME,fprintf(stderr,"Export_All_Transforms()\n"));

	fprintf(outfile, "// Transformations\n");

	for ( inst_elmt = insts ; inst_elmt ; inst_elmt = inst_elmt->next )
		if ( inst_elmt->the_instance->o_parent->b_class != plane_obj )
			Export_Transform(outfile, inst_elmt->the_instance);

	return fprintf(outfile, "\n");
}


static void
Export_CSG_Transforms(FILE *outfile, CSGNodePtr tree)
{
	if ( ! tree ) return;

	if ( tree->csg_op == csg_leaf_op )
		Export_Transform(outfile, tree->csg_instance);
	else
	{
		Export_CSG_Transforms(outfile, tree->csg_left_child);
		Export_CSG_Transforms(outfile, tree->csg_right_child);
	}
}


static void
Export_CSG_Bases(FILE *outfile, CSGNodePtr tree)
{
	if ( ! tree ) return;

	if ( tree->csg_op == csg_leaf_op )
	{
		if ( tree->csg_instance->o_parent->b_class == csg_obj ||
			 tree->csg_instance->o_parent->b_class == wireframe_obj )
			Export_Basetypes(outfile, tree->csg_instance->o_parent);
	}
	else
	{
		Export_CSG_Bases(outfile, tree->csg_left_child);
		Export_CSG_Bases(outfile, tree->csg_right_child);
	}
}



static int
Export_Basetypes(FILE *outfile, BaseObjectPtr base_obj)
{
	if ( Hash_Get_Value(base_hash, (long)base_obj) != (void*)-1 )
		return 1;

	if ( base_obj->b_class == csg_obj )
	{
		Export_CSG_Transforms(outfile, base_obj->b_csgptr);
		Export_CSG_Bases(outfile, base_obj->b_csgptr);
	}

	/* Save information about non-default base objects. */
	fprintf(outfile, "// BaseObjects\n");

 	fprintf(outfile, "#declare %s =\n", base_obj->b_label);
	if ( base_obj->b_class == csg_obj )
		Export_CSG_Tree(outfile, base_obj->b_csgptr);
	else
		Export_Wireframe(outfile, base_obj->b_major_wire);

	Hash_Insert(base_hash, (long)base_obj, (void*)base_obj);

	return fprintf(outfile, "\n");
}


static int
Export_CSG_Tree(FILE *outfile, CSGNodePtr tree)
{
	if ( ! tree ) return 1;

	if ( tree->csg_op == csg_leaf_op )
	{
		fprintf(outfile, "// %s\n", tree->csg_instance->o_label);

		Export_Object_Type(outfile, tree->csg_instance->o_parent);
		if ( tree->csg_instance->o_parent->b_class == plane_obj )
		{
			Vector	zero_v;
			Vector	normal;
			Matrix	inverse;
			double	temp_d;

			inverse = MInvert(&(tree->csg_instance->o_transform.matrix));
			normal = inverse.z;
			VUnit(normal, temp_d, normal);
			VNew(0, 0, 0, zero_v);
			fprintf(outfile, "\t");
			POVVPrint(normal);
			fprintf(outfile, "\t, %g\n",
					-Distance_Point_To_Plane(normal,
						tree->csg_instance->o_transform.displacement,
						zero_v));
		}

		if ( ((AttributePtr)tree->csg_instance->o_attribs)->use_obj_trans )
			Export_Attributes(outfile,
							  ((AttributePtr)tree->csg_instance->o_attribs));

		if ( tree->csg_instance->o_parent->b_class != plane_obj )
		{
			fprintf(outfile, "\ttransform transform_%ld\n",
			(long)Hash_Get_Value(transform_hash, (long)(tree->csg_instance)));
		}

		if ( ! ((AttributePtr)tree->csg_instance->o_attribs)->use_obj_trans )
			Export_Attributes(outfile,
							  ((AttributePtr)tree->csg_instance->o_attribs));
	}
	else
	{
		switch ( tree->csg_op )
		{
			case csg_union_op: 
				fprintf(outfile, "union { \n");
				break;
			case csg_intersection_op: 
				fprintf(outfile, "intersection { \n");
				break;
			case csg_difference_op: 
				fprintf(outfile, "difference { \n");
				break;
			default:;
		}

		Export_CSG_Tree(outfile, tree->csg_left_child);
		Export_CSG_Tree(outfile, tree->csg_right_child);
	}

	return fprintf(outfile, "}\n");
}


static void
Export_Face(FILE *outfile, WireframePtr src, FacePtr face)
{
	int	i;

	if ( face->num_vertices > 3 )
	{
		/* Triangulate it. */
		WireframePtr face_wire = Face_Triangulate(src, face);

		for ( i = 0 ; i < face_wire->num_faces ; i++ )
			Export_Face(outfile, face_wire, face_wire->faces + i);

		Wireframe_Destroy(face_wire);

		return;
	}

	if ( src->vertex_normals )
	{
		fprintf(outfile, "smooth_triangle {\n\t");
		POVVPrint(src->vertices[face->vertices[0]]);
		fprintf(outfile, "\t,");
		POVVPrint(src->vertex_normals[face->vertices[0]]);
		fprintf(outfile, "\t,");
		POVVPrint(src->vertices[face->vertices[2]]);
		fprintf(outfile, "\t,");
		POVVPrint(src->vertex_normals[face->vertices[2]]);
		fprintf(outfile, "\t,");
		POVVPrint(src->vertices[face->vertices[1]]);
		fprintf(outfile, "\t,");
		POVVPrint(src->vertex_normals[face->vertices[1]]);
	}
	else
	{
		fprintf(outfile, "triangle {\n\t");
		POVVPrint(src->vertices[face->vertices[0]]);
		fprintf(outfile, "\t,");
		POVVPrint(src->vertices[face->vertices[1]]);
		fprintf(outfile, "\t,");
		POVVPrint(src->vertices[face->vertices[2]]);
	}

	Export_Attributes(outfile, face->face_attribs);
	fprintf(outfile, "}\n");
}


static int
Export_Wireframe(FILE *outfile, WireframePtr wire)
{
	int	i;

	fprintf(outfile, "union {\n");

	for ( i = 0 ; i < wire->num_faces ; i++ )
		Export_Face(outfile, wire, wire->faces + i);

	return fprintf(outfile, "}\n");
}


static int
Export_Instances(FILE *outfile, InstanceList insts)
{
	InstanceList		inst_elmt;
	ObjectInstancePtr	inst;

	debug(FUNC_NAME,fprintf(stderr,"Export_Instances()\n"));

	fprintf(outfile, "// Instances\n");

	for ( inst_elmt = insts ; inst_elmt != NULL ; inst_elmt = inst_elmt->next )
	{
		inst = inst_elmt->the_instance;

		if ( inst->o_parent->b_class == light_obj ||
			 inst->o_parent->b_class == spotlight_obj ||
			 inst->o_parent->b_class == arealight_obj )
			Export_Light(outfile, inst);
		else
		{
			if ( inst->o_parent->b_class == csg_obj ||
				 inst->o_parent->b_class == wireframe_obj )
				Export_Basetypes(outfile, inst->o_parent);

			fprintf(outfile, "// %s\n", inst->o_label);

			Export_Object_Type(outfile, inst->o_parent);

			if ( inst->o_parent->b_class == plane_obj )
			{
				Vector	zero_v;
				Matrix	inverse;
				Vector	normal;
				double	temp_d;

				inverse = MInvert(&(inst->o_transform.matrix));
				normal = inverse.z;
				VUnit(normal, temp_d, normal);
				VNew(0, 0, 0, zero_v);
				fprintf(outfile, "\t");
				POVVPrint(normal);
				fprintf(outfile, "\t, %g\n",
						-Distance_Point_To_Plane(normal,
												inst->o_transform.displacement,
												zero_v));
			}

			if ( ((AttributePtr)inst->o_attribs)->use_obj_trans )
				Export_Attributes(outfile, ((AttributePtr)inst->o_attribs));

			if ( inst->o_parent->b_class != plane_obj )
			{
				fprintf(outfile, "\ttransform transform_%ld\n",
						(long)Hash_Get_Value(transform_hash, (long)inst));
			}

			if ( ! ((AttributePtr)inst->o_attribs)->use_obj_trans )
				Export_Attributes(outfile, ((AttributePtr)inst->o_attribs));

			if ( ((AttributePtr)inst->o_attribs)->open )
				fprintf(outfile, "\topen\n");

			/* Export bounds, if relevent. */
			if ( inst->o_parent->b_class == csg_obj )
			{
				Cuboid	bound;

				bound = Transform_Bound(&(inst->o_parent->b_csgptr->csg_bound),
										&(inst->o_transform));
				fprintf(outfile, "\tbounded_by { box {\n");
				fprintf(outfile, "\t\t");
				POVVPrint(bound.min);
				fprintf(outfile, "\t\t,");
				POVVPrint(bound.max);
				fprintf(outfile, "\t\t}}\n");
			}

			fprintf(outfile, "}\n\n");
		}
	}

	return fprintf(outfile, "\n");
}


static void
Export_Object_Type(FILE *outfile, BaseObjectPtr base)
{
	switch ( base->b_class )
	{
		case sphere_obj:
			fprintf(outfile, "sphere { <0,0,0>, 1.0\n");
			break;
		case cylinder_obj:
			fprintf(outfile, "cylinder { <0,0,-1>, <0,0,1>, 1.0\n");
			break;
		case cone_obj:
			fprintf(outfile, "cone { <0,0,-1>, 1, <0,0,1>, 0\n");
			break;
		case cube_obj:
			fprintf(outfile, "box { <-1,-1,-1>, <1,1,1>\n");
			break;
		case plane_obj:
			fprintf(outfile, "plane {\n");
			break;
		case square_obj:
			fprintf(outfile, "box { <-1,-1,-0.001>, <1,1,0.001>\n");
			break;
		case csg_obj:
		case wireframe_obj:
			fprintf(outfile, "object { %s\n", base->b_label);
			break;
		default:;
	}
}



static void
Export_Attributes(FILE *outfile, AttributePtr attribs)
{
	if ( ! attribs || ! attribs->defined )
		return;

	if ( ! attribs->use_extension )
	{
		fprintf(outfile, "\tpigment\n");
		fprintf(outfile, "\t\t{ color red %g green %g blue %g filter %g}\n",
				attribs->colour.red / (double)MAX_UNSIGNED_SHORT,
				attribs->colour.green / (double)MAX_UNSIGNED_SHORT,
				attribs->colour.blue / (double)MAX_UNSIGNED_SHORT,
				attribs->transparency);
		fprintf(outfile, "\tfinish {\n");
		fprintf(outfile, "\t\tdiffuse %g\n", attribs->diff_coef);
		fprintf(outfile, "\t\tambient ambient_light_level\n");
		fprintf(outfile, "\t\tspecular %g\n", attribs->spec_coef);
		fprintf(outfile, "\t\treflection %g\n", attribs->reflect_coef);
		fprintf(outfile, "\t\trefraction 1.0\n");
		fprintf(outfile, "\t\tior %g\n", attribs->refract_index);
		fprintf(outfile, "\t}\n");
	}
	else
		fprintf(outfile, "%s\n", attribs->extension);
}


static int
Export_Includes(FILE *outfile)
{
	int	i = 0;

	debug(FUNC_NAME,fprintf(stderr,"Export_Includes()\n"));

	if ( ! includes ) return 1;

	while ( includes[i] != '\0' )
	{
		fprintf(outfile, "#include \"");
		while ( isspace(includes[i]) ) i++;
		do
		{
			fputc((int)includes[i++], outfile);
		} while ( ! isspace(includes[i]) );
		while ( isspace(includes[i]) ) i++;
		fprintf(outfile, "\"\n");
	}

	return fprintf(outfile, "\n");
}


static int
Export_Declarations(FILE *outfile, XColor amb)
{
	double	ambient;

	/* Export ambient identifier. */
	ambient = ( amb.red + amb.green + amb.blue ) /
			  (double)( 3 * MAX_UNSIGNED_SHORT );
	fprintf(outfile, "#declare ambient_light_level = %g\n", ambient);

	/* This is simple at this stage. Just dump the string. */
	if ( declarations )
		fprintf(outfile, "\n%s\n\n", declarations);

	return fprintf(outfile, "\n");
}


void
POV_Includes_Callback(Widget w, XtPointer cl, XtPointer ca)
{
	if ( ! pov_include_shell )
		POV_Create_Include_Dialog();

	SFpositionWidget(pov_include_shell);

	XtPopup(pov_include_shell, XtGrabExclusive);
}


/*	Adds an include file to the list of files to include when exporting.
*/
void
POV_Add_Include(char *filename)
{
	if ( filename[0] == '\0' )
		return;

	if ( includes )
	{
		includes = More(includes, char,
						strlen(includes) + strlen(filename) + 5);
		strcat(includes, filename);
	}
	else
	{
		includes = New(char, strlen(filename) + 5);
		strcpy(includes, filename);
	}
	if ( filename[strlen(filename) - 1] != '\n' )
		strcat(includes, "\n");

	if ( ! pov_include_shell )
		POV_Create_Include_Dialog();

	XtVaSetValues(pov_include_text, XtNstring, includes, NULL);
}


/*	Clears all the include files.
*/
void
POV_Clear_Includes()
{
	if ( includes )
		free(includes);
	includes = NULL;
}


/*	Saves includes.
*/
int
POV_Save_Includes(FILE *outfile)
{
	int	i = 0;

	if ( ! includes ) return 1;

	fprintf(outfile, "Include\n");

	while ( includes[i] != '\0' )
	{
		fprintf(outfile, "\"");
		do
		{
			fputc((int)includes[i++], outfile);
		} while ( includes[i] != '\n' && includes[i] != '\0' );
		if ( includes[i] != '\0' ) i++;
		fprintf(outfile, "\"\n");
	}

	return fprintf(outfile, "\n");
}

static void
Add_Include_Callback(Widget w, XtPointer cl, XtPointer ca)
{
	char	*temp_string;

	XtPopdown(pov_include_shell);

	/* Free the old string, then take what's in the dialog and
	** add it a a new set of includes.
	*/
	POV_Clear_Includes();
	XtVaGetValues(pov_include_text, XtNstring, &temp_string, NULL);
	POV_Add_Include(temp_string);
}


static void
POV_Create_Include_Dialog()
{
	Arg		args[15];
	int		n, m;
	Widget	form;
	Widget	existing_label;
	Widget	done, cancel;
	Dimension	height;

	n = 0;
	XtSetArg(args[n], XtNtitle, "POV Includes");	n++;
	XtSetArg(args[n], XtNallowShellResize, TRUE);	n++;
	pov_include_shell = XtCreatePopupShell("povIncludeShell",
						transientShellWidgetClass, main_window.shell, args, n);

	n = 0;
	form = XtCreateManagedWidget("povIncludeForm", formWidgetClass,
						pov_include_shell, args, n);

	m = 0;
	XtSetArg(args[m], XtNtop, XtChainTop);		m++;
	XtSetArg(args[m], XtNbottom, XtChainTop);	m++;
	XtSetArg(args[m], XtNleft, XtChainLeft);	m++;
	XtSetArg(args[m], XtNright, XtChainLeft);	m++;
	XtSetArg(args[m], XtNresizable, TRUE);		m++;

	n = m;
	XtSetArg(args[n], XtNlabel, "Current includes:");	n++;
	XtSetArg(args[n], XtNborderWidth, 0);				n++;
	existing_label = XtCreateManagedWidget("povIncludeExistingLabel",
						labelWidgetClass, form, args, n);

	XtVaGetValues(existing_label, XtNheight, &height, NULL);

	n = m;
	XtSetArg(args[n], XtNheight, (int)height * 6);	n++;
	XtSetArg(args[n], XtNstring, "");				n++;
	XtSetArg(args[n], XtNeditType, XawtextEdit);	n++;
	XtSetArg(args[n], XtNresize, TRUE);				n++;
	XtSetArg(args[n], XtNscrollVertical, XawtextScrollWhenNeeded);	n++;
	XtSetArg(args[n], XtNfromVert, existing_label);	n++;
	pov_include_text = XtCreateManagedWidget("povIncludeExistingText",
						asciiTextWidgetClass, form, args, n);

	n = m;
	XtSetArg(args[n], XtNlabel, "Done");				n++;
	XtSetArg(args[n], XtNfromVert, pov_include_text);	n++;
#if ( USE_ROUNDED_BUTTONS == 1 )
	XtSetArg(args[n], XtNshapeStyle, XmuShapeRoundedRectangle);	n++;
	XtSetArg(args[n], XtNcornerRoundPercent, 30);				n++;
	XtSetArg(args[n], XtNhighlightThickness, 2);				n++;
#endif
	done = XtCreateManagedWidget("povIncludeDoneButton", commandWidgetClass,
								form, args, n);
	XtAddCallback(done, XtNcallback, Add_Include_Callback, NULL);

	n = m;
	XtSetArg(args[n], XtNlabel, "Cancel");				n++;
	XtSetArg(args[n], XtNfromVert, pov_include_text);	n++;
	XtSetArg(args[n], XtNfromHoriz, done);				n++;
#if ( USE_ROUNDED_BUTTONS == 1 )
	XtSetArg(args[n], XtNshapeStyle, XmuShapeRoundedRectangle);	n++;
	XtSetArg(args[n], XtNcornerRoundPercent, 30);				n++;
	XtSetArg(args[n], XtNhighlightThickness, 2);				n++;
#endif
	cancel = XtCreateManagedWidget("povIncludeCancelButton", commandWidgetClass,
								form, args, n);
	XtAddCallback(cancel, XtNcallback, POV_Cancel_Callback,
					(XtPointer)pov_include_shell);

	XtRealizeWidget(pov_include_shell);
}


static void
POV_Cancel_Callback(Widget w, XtPointer cl, XtPointer ca)
{
	XtPopdown((Widget)cl);
}

